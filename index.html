<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>鳴潮 音骸スコアチェッカー</title>
<link rel="stylesheet" href="styles.css" />
</head>
<body>
<div class="main">
  <div class="header">
    <div class="title">鳴潮 音骸スコアチェッカー</div>
    <div class="badge">ゼロ・ウェイティング</div>
  </div>
  <p class="lead">ステータス画面をコピーしてペーストしてください (Ctrl+V)。モデルは起動直後にウォームアップされます。</p>
  <div class="status-row">
    <div class="status-text" id="status">モデル読み込み中...</div>
    <div class="badge" aria-live="polite">リアルタイム解析</div>
  </div>
  <div class="score-box">
    <span class="score-label">Score</span>
    <span class="score-value" id="score">--</span>
  </div>
  <div class="button-row">
    <button class="btn" id="reset-btn" type="button">リセット</button>
    <button class="btn" id="sample-btn" type="button">サンプル画像でテスト</button>
  </div>
  <div class="hint">ペーストを検知するとバックグラウンドで非同期推論を実行します。UIはブロックされません。</div>
</div>
<canvas id="hidden" width="1920" height="1080"></canvas>

<script type="module">
import * as tf from "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js";

const statusEl = document.getElementById("status");
const scoreEl = document.getElementById("score");
const hidden = document.getElementById("hidden");
const ctx = hidden.getContext("2d");
const resetBtn = document.getElementById("reset-btn");
const sampleBtn = document.getElementById("sample-btn");

const worker = new Worker(URL.createObjectURL(new Blob([`
  self.onmessage = async (ev) => {
    const { imageData, boxes, modelUrl, classes, weights } = ev.data;
    const { data, width, height } = imageData;
    // simple binarization
    const bin = (arr) => {
      const out = new Uint8ClampedArray(arr.length/4);
      for (let i=0,j=0;i<arr.length;i+=4,++j){
        const g = (arr[i]+arr[i+1]+arr[i+2]) / 3;
        out[j] = g > 128 ? 255 : 0;
      }
      return out;
    };
    const tfjs = await import(modelUrl);
    const model = await tfjs.loadGraphModel(weights);
    const preds = [];
    const binAll = bin(data);
    for (const b of boxes){
      const {x,y,w,h} = b;
      const crop = new Uint8Array(w*h);
      for (let row=0; row<h; ++row){
        for (let col=0; col<w; ++col){
          const srcIdx = (y+row)*width + (x+col);
          crop[row*w + col] = binAll[srcIdx];
        }
      }
      // resize to 18x18 nearest
      const tgt = 18, resized = new Float32Array(tgt*tgt);
      for (let r=0; r<tgt; ++r){
        for (let c=0; c<tgt; ++c){
          const sr = Math.floor(r * h / tgt);
          const sc = Math.floor(c * w / tgt);
          resized[r*tgt+c] = crop[sr*w+sc] / 255;
        }
      }
      const input = tf.tensor(resized, [1, tgt, tgt, 1]);
      const p = model.predict(input);
      const idx = (await p.argMax(-1).data())[0];
      preds.push(classes[idx]);
      tf.dispose([input, p]);
    }
    model.dispose();
    self.postMessage(preds);
  };
`], { type: "application/javascript" })));

const CLASSES = []; // will fetch
const BOXES_1080P = [
  {x:1500,y:200,w:24,h:32,name:"digit0"},
  // fill all needed boxes in status area
];

let modelPath = "web_model/model.json";
let model; let warm = false;

async function init() {
  statusEl.textContent = "TensorFlow.js 読み込み...";
  await tf.setBackend("webgl");
  await tf.ready();
  model = await tf.loadGraphModel(modelPath);
  await model.predict(tf.zeros([1,18,18,1])).data(); // warm-up
  const res = await fetch("web_model/classes.json");
  CLASSES.push(...await res.json());
  warm = true;
  statusEl.textContent = "準備完了。画像をペーストしてください。";
}
init();

function scaleBoxes(w, h) {
  const sx = w / 1920, sy = h / 1080;
  return BOXES_1080P.map(b => ({
    x: Math.round(b.x * sx),
    y: Math.round(b.y * sy),
    w: Math.round(b.w * sx),
    h: Math.round(b.h * sy),
    name: b.name
  }));
}

document.addEventListener("paste", async (e) => {
  if (!warm) return;
  const item = [...e.clipboardData.items].find(i => i.type.startsWith("image/"));
  if (!item) { statusEl.textContent = "画像が見つかりませんでした"; return; }
  const file = item.getAsFile();
  const bmp = await createImageBitmap(file);
  hidden.width = bmp.width; hidden.height = bmp.height;
  ctx.drawImage(bmp, 0, 0);
  const imgData = ctx.getImageData(0, 0, bmp.width, bmp.height);
  statusEl.textContent = "解析中...";
  worker.onmessage = (ev) => {
    const preds = ev.data; // per box labels
    // TODO: map preds to fields and compute score
    const score = computeScore(preds);
    scoreEl.textContent = score.toFixed(2);
    statusEl.textContent = "完了";
  };
  worker.postMessage({
    imageData: imgData,
    boxes: scaleBoxes(bmp.width, bmp.height),
    modelUrl: "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js",
    classes: CLASSES,
    weights: location.origin + "/web_model/model.json"
  });
});

function computeScore(preds){
  // Example mapping; replace with your weights
  const weights = { "会心":2.0, "攻撃":1.0, "％":1.0 };
  let s = 0;
  for (const p of preds){
    if (weights[p]) s += weights[p];
    else if (!isNaN(Number(p))) s += Number(p);
  }
  return s;
}

// UI helpers
resetBtn.addEventListener("click", () => {
  scoreEl.textContent = "--";
  statusEl.textContent = "リセットしました。画像をペーストしてください。";
});

sampleBtn.addEventListener("click", () => {
  statusEl.textContent = "サンプル画像機能は未設定です。クリップボードからペーストしてください。";
});
</script>
</body>
</html>